#created on: Nov 20, 2011
package com.rakursy.timetable.rules;
	dialect "java"

import org.drools.planner.core.score.constraint.ConstraintType;
import org.drools.planner.core.score.constraint.IntConstraintOccurrence;
import org.drools.planner.core.score.buildin.hardandsoft.HardAndSoftScoreHolder;

import com.rakursy.timetable.model.*;
import java.util.ArrayList;
import java.lang.Math;

global HardAndSoftScoreHolder scoreHolder;

// ############################################################################
// # Hard constraints
// ############################################################################

// A teacher cannot teach 2 classes at the same time
rule "conflictingTeacherTimes"
    when
    	$sg1 : StudentGroup( $teacher : teacher )
    	$sg2 : StudentGroup( teacher == $teacher )
    	$sc1 : SchoolClass( studentGroup == $sg1, $period : period, $uuid : uuid )
    	$sc2 : SchoolClass( studentGroup == $sg2, period == $period, uuid > $uuid )
    then
        insertLogical(new IntConstraintOccurrence("conflictingTeacherTimes", ConstraintType.NEGATIVE_HARD, 
        		40, 
        		$sc1, $sc2, $teacher));
end

// A grade cannot have 2 classes at the same time
rule "conflictingGradeTimes"
    when
    	$sg1 : StudentGroup( $grade : grade, $subject : subject )
    	$sg2 : StudentGroup( grade == $grade, subject != $subject )
    	$sc1 : SchoolClass( studentGroup == $sg1, $period : period, $uuid : uuid )
    	$sc2 : SchoolClass( studentGroup == $sg2, period == $period, uuid > $uuid )
    then
        insertLogical(new IntConstraintOccurrence("conflictingGradeTimes", ConstraintType.NEGATIVE_HARD, 
        		40,
        		$sc1, $sc2, $sg1, $sg2));
end

// A room cannot host 2 classes at the same time
rule "conflictingRoomTimes"
	when
    	$sc1 : SchoolClass( $room : room, $period : period, $uuid : uuid )
    	$sc2 : SchoolClass( room == $room, period == $period, uuid > $uuid )
	then
        insertLogical(new IntConstraintOccurrence("conflictingRoomTimes", ConstraintType.NEGATIVE_HARD, 
        		40, 
        		$sc1, $sc2, $room));
end

// The total number of seats in the room of a given school class cannot be lower than the number of students
rule "roomCapacityMustSuffice"
	when
		$room : Room( $capacity : capacity )
		SchoolClass( room == $room, studentGroup.studentCount > $capacity, $studentCount : studentGroup.studentCount )
	then
		insertLogical(new IntConstraintOccurrence("roomCapacityMustSuffice", ConstraintType.NEGATIVE_HARD,
				$studentCount - $capacity,
				$room));
end

// A room can only host subjects which are in the room's possible subjects list
rule "roomCannotBeHostToAllSubjects"
	when
		$subject : Subject()
		$room : Room( possibleSubjects not contains $subject )
		$sc : SchoolClass( room == $room, subject == $subject )
	then
		insertLogical(new IntConstraintOccurrence("roomCannotBeHostToAllSubjects", ConstraintType.NEGATIVE_HARD,
				35, 
				$sc, $room, $subject));
end

rule "teacherCanOnlyTeachSomeSubjects"
	when
		$subject : Subject()
		$teacher : Teacher( subjects not contains $subject )
		$sc : SchoolClass( teacher == $teacher, subject == $subject )
	then
		insertLogical(new IntConstraintOccurrence("teacherCanOnlyTeachSomeSubjects", ConstraintType.NEGATIVE_HARD,
				25, 
				$sc, $teacher, $subject));
end

rule "studentGroupsMustHaveTheSameClass"
	when
		$sg1 : StudentGroup()
		$sg2 : StudentGroup( linkedWith contains $sg1 )
		$sc : SchoolClass( studentGroup == $sg1, $period : period )
		not SchoolClass( studentGroup == $sg2, period == $period )
	then
		insertLogical(new IntConstraintOccurrence("studentGroupsMustHaveTheSameClass", ConstraintType.NEGATIVE_HARD,
				15,
				$sc, $sg1, $sg2, $period));
end

rule "studentGroupsMustBeInDifferentRooms"
	when
		$sg1 : StudentGroup()
		$sg2 : StudentGroup( linkedWith contains $sg1 )
		$sc1 : SchoolClass( studentGroup == $sg1, $period : period, $room : room )
		$sc2 : SchoolClass( studentGroup == $sg2, period == $period, room == $room )
	then
		insertLogical(new IntConstraintOccurrence("studentGroupsMustBeInDifferentRooms", ConstraintType.NEGATIVE_HARD,
				15,
				$sc1, $sc2, $sg1, $sg2, $room));
end

rule "studentGroupCounterpartTeacherMustNotConflict"
	when
		$sg1 : StudentGroup()
		$sg2 : StudentGroup( linkedWith contains $sg1 )
		$sc1 : SchoolClass( studentGroup == $sg1, $period : period )
		$sc2 : SchoolClass( studentGroup != $sg2, teacher == $sg2.teacher, period == $period, $teacher : teacher )
	then
		insertLogical(new IntConstraintOccurrence("studentGroupCounterpartsMustNotConflict", ConstraintType.NEGATIVE_HARD,
				30,
				$sc1, $sc2, $sg1, $sg2, $period, $teacher));
end

rule "schoolClassesMustBeInARow"
	when
		$schoolDay : SchoolDay()
		SchoolClass( $grade : studentGroup.grade, schoolDay == $schoolDay, $period1 : period )
		SchoolClass( studentGroup.grade == $grade, schoolHourStartTime > $period1.schoolHour.actualStartTime + 1, 
				schoolDay == $schoolDay, $period2 : period )
				
		not( SchoolClass( schoolHourStartTime > $period1.schoolHour.actualStartTime 
						&& schoolHourStartTime < $period2.schoolHour.actualStartTime,
						schoolDay == $schoolDay,
						studentGroup.grade == $grade ) )
	then
		insertLogical(new IntConstraintOccurrence("schoolClassesMustBeInARow", ConstraintType.NEGATIVE_HARD, 
				Math.abs($period1.getSchoolHour().getActualStartTime() - $period2.getSchoolHour().getActualStartTime()), 
				$period1, $period2, $grade));
end

rule "schoolClassesMustStartAtTheBeginnining"
	when
		$grade : Grade()
		$schoolDay : SchoolDay()
		SchoolClass( studentGroup.grade == $grade, schoolHourStartTime > 1, schoolDay == $schoolDay, $period : period )
		not( exists( SchoolClass( studentGroup.grade == $grade, schoolDay == $schoolDay, schoolHourStartTime < $period.schoolHour.actualStartTime ) ) )
		
		#$period : Period( schoolHour.actualStartTime == 1 )
		#not( SchoolClass( studentGroup.grade == $grade, period == $period ) )
	then
		insertLogical(new IntConstraintOccurrence("schoolClassesMustStartAtTheBeginnining", ConstraintType.NEGATIVE_HARD, 
				$period.getSchoolHour().getActualStartTime(),
				$grade, $period));
end

rule "gradesMustHaveAtLeastFourClassesADay"
	when
		$schoolDay : SchoolDay()
		$grade : Grade()
		Number(intValue < 4, $value : intValue) from accumulate ( SchoolClass( studentGroup.grade == $grade, schoolDay == $schoolDay, $uuid : uuid ) , count( $uuid ) )
	then
		insertLogical(new IntConstraintOccurrence("gradesMustHaveAtLeastFourClassesADay", ConstraintType.NEGATIVE_HARD, 
				4 - $value,
				$grade, $schoolDay));
end


// ############################################################################
// # Soft constraints
// ############################################################################

rule "optimalSchoolClassPlacement"
	when
		$schoolDay : SchoolDay()
		SchoolClass( $subject : subject, $grade : studentGroup.grade, $period1 : period, schoolDay == $schoolDay, $uuid : uuid )
		SchoolClass( subject == $subject, studentGroup.grade == $grade, $period2 : period, schoolDay == $schoolDay, uuid > $uuid )
		eval( Math.abs($period1.getSchoolHour().getActualStartTime() - $period2.getSchoolHour().getActualStartTime() ) > 1 )
	then
		insertLogical(new IntConstraintOccurrence("optimalSchoolClassPlacement", ConstraintType.NEGATIVE_SOFT, 
				Math.abs($period1.getSchoolHour().getActualStartTime() - $period2.getSchoolHour().getActualStartTime()) ));
end

rule "optimalSchoolClassesForTeachers"
	when
		$schoolDay : SchoolDay()
		SchoolClass( $teacher : teacher, $period1 : period, schoolDay == $schoolDay, $uuid : uuid )
		SchoolClass( teacher == $teacher, $period2 : period, schoolDay == $schoolDay, $uuid > uuid )
		eval( Math.abs($period1.getSchoolHour().getActualStartTime() - $period2.getSchoolHour().getActualStartTime() ) > 1 )
	then
		insertLogical(new IntConstraintOccurrence("optimalSchoolClassPlacement", ConstraintType.NEGATIVE_SOFT, 
				Math.abs($period1.getSchoolHour().getActualStartTime() - $period2.getSchoolHour().getActualStartTime()) ));
end

rule "schoolClassesInClassRoomIfPossible"
	when
		$subject : Subject()
		$room : Room( possibleSubjects contains $subject )
		$grade : Grade( classRoom == $room )
		SchoolClass( subject == $subject, studentGroup.grade == $grade, room != $room, $period : period, $uuid : uuid )
		not(exists( SchoolClass( subject  == $subject, studentGroup.grade == $grade, room == $room, period == $period, uuid != $uuid ) ))
	then
		insertLogical(new IntConstraintOccurrence("schoolClassesInClassRoomIfPossible", ConstraintType.NEGATIVE_SOFT, 
				$subject, $room, $grade));
end

rule "schoolClassesProperlyDistributed"
	when
		$grade : Grade()
		$schoolDay1 : SchoolDay()
		$schoolDay2 : SchoolDay(this != $schoolDay1)
		$classesInSchoolDay1 : Number() from accumulate ( SchoolClass( studentGroup.grade == $grade, schoolDay == $schoolDay1, $uuid : uuid ) , count( $uuid ) )
		$classesInSchoolDay2 : Number() from accumulate ( SchoolClass( studentGroup.grade == $grade, schoolDay == $schoolDay2, $uuid : uuid ) , count( $uuid ) )
		eval( Math.abs($classesInSchoolDay1.intValue() - $classesInSchoolDay2.intValue()) > 2 )
	then
		insertLogical(new IntConstraintOccurrence("schoolClassesProperlyDistributed", ConstraintType.NEGATIVE_SOFT, 
				Math.abs($classesInSchoolDay1.intValue() - $classesInSchoolDay2.intValue()), 
				$schoolDay1, $schoolDay2, $classesInSchoolDay1, $classesInSchoolDay2));
end

rule "periodOffRequestsShouldBeSatisfied"
	when
		$grade : Grade()
		PeriodOffRequest( $teacher : teacher, $dayOfWeek : dayOfWeek, $schoolHourStartTime : schoolHourStartTime )
		$period : Period( schoolDay.dayOfWeek == $dayOfWeek, schoolHour.actualStartTime == $schoolHourStartTime )
		SchoolClass( studentGroup.grade == $grade, teacher == $teacher, period == $period )
	then
		insertLogical(new IntConstraintOccurrence("periodOffRequestsShouldBeSatisfied", ConstraintType.NEGATIVE_SOFT, 
				$teacher, $period));
end

// ############################################################################
// # Calculate score
// ############################################################################

// Accumulate hard constraints
rule "hardConstraintsBroken"
        salience -1 // Do the other rules first (optional, for performance)
    when
        $hardTotal : Number() from accumulate(
            IntConstraintOccurrence(constraintType == ConstraintType.NEGATIVE_HARD, $weight : weight),
            sum($weight)
        )
    then
        scoreHolder.setHardConstraintsBroken($hardTotal.intValue());
end

// Accumulate soft constraints
rule "softConstraintsBroken"
        salience -1 // Do the other rules first (optional, for performance)
    when
        $softTotal : Number() from accumulate(
            IntConstraintOccurrence(constraintType == ConstraintType.NEGATIVE_SOFT, $weight : weight),
            sum($weight) 
        )
    then
        scoreHolder.setSoftConstraintsBroken($softTotal.intValue());
end

